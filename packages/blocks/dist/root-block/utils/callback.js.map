{"version":3,"file":"callback.js","sourceRoot":"","sources":["../../../src/root-block/utils/callback.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,YAAY,EAAE,MAAM,0BAA0B,CAAC;AAIxD,OAAO,EACL,uBAAuB,EACvB,SAAS,GACV,MAAM,8BAA8B,CAAC;AAEtC,MAAM,CAAC,KAAK,UAAU,kBAAkB,CACtC,UAAsB,EACtB,KAAiB,EACjB,QAAmC;IAEnC,MAAM,QAAQ,GAAG,MAAM,uBAAuB,CAAC,UAAU,EAAE,KAAK,CAAC,CAAC;IAClE,YAAY,CAAC,QAAQ,EAAE,4BAA4B,CAAC,CAAC;IACrD,MAAM,QAAQ,CAAC,cAAc,CAAC;IAC9B,MAAM,YAAY,GAAG,QAAQ,CAAC,YAAY,CAAC;IAC3C,YAAY,CAAC,YAAY,EAAE,iCAAiC,CAAC,CAAC;IAC9D,YAAY,CAAC,KAAK,CAAC,cAAc,CAAC,IAAI,CAAC,GAAG,EAAE;QAC1C,IAAI,QAAQ,EAAE,CAAC;YACb,QAAQ,CAAC,QAAQ,CAAC,CAAC;QACrB,CAAC;IACH,CAAC,CAAC,CAAC;AACL,CAAC;AAED,oDAAoD;AACpD,uFAAuF;AACvF,mCAAmC;AACnC,6CAA6C;AAC7C,mCAAmC;AACnC,MAAM,CAAC,KAAK,UAAU,qBAAqB,CACzC,UAAsB,EACtB,KAAiB,EACjB,QAA8C;IAE9C,MAAM,IAAI,GAAG,KAAK,CAAC,GAAG,CAAC;IACvB,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAExB,MAAM,WAAW,GAAG,UAAU,CAAC,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC;IAC1E,IAAI,CAAC,WAAW;QAAE,OAAO;IACzB,MAAM,WAAW,CAAC,cAAc,CAAC;IAEjC,MAAM,OAAO,GAAG,UAAU,CAAC,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC;IACxE,IAAI,OAAO;QAAE,QAAQ,CAAC,OAAO,CAAC,CAAC;AACjC,CAAC","sourcesContent":["import type { BlockElement, EditorHost } from '@blocksuite/block-std';\nimport { assertExists } from '@blocksuite/global/utils';\nimport type { BlockModel } from '@blocksuite/store';\n\nimport type { RichText } from '../../_common/components/rich-text/rich-text.js';\nimport {\n  asyncGetRichTextByModel,\n  buildPath,\n} from '../../_common/utils/query.js';\n\nexport async function onModelTextUpdated(\n  editorHost: EditorHost,\n  model: BlockModel,\n  callback?: (text: RichText) => void\n) {\n  const richText = await asyncGetRichTextByModel(editorHost, model);\n  assertExists(richText, 'RichText is not ready yet.');\n  await richText.updateComplete;\n  const inlineEditor = richText.inlineEditor;\n  assertExists(inlineEditor, 'Inline editor is not ready yet.');\n  inlineEditor.slots.renderComplete.once(() => {\n    if (callback) {\n      callback(richText);\n    }\n  });\n}\n\n// Run the callback until a model's element updated.\n// Please notice that the callback will be called **once the element itself is ready**.\n// The children may be not updated.\n// If you want to wait for the text elements,\n// please use `onModelTextUpdated`.\nexport async function onModelElementUpdated(\n  editorHost: EditorHost,\n  model: BlockModel,\n  callback: (blockElement: BlockElement) => void\n) {\n  const page = model.doc;\n  assertExists(page.root);\n\n  const rootElement = editorHost.view.viewFromPath('block', [page.root.id]);\n  if (!rootElement) return;\n  await rootElement.updateComplete;\n\n  const element = editorHost.view.viewFromPath('block', buildPath(model));\n  if (element) callback(element);\n}\n"]}