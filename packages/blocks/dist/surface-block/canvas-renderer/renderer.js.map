{"version":3,"file":"renderer.js","sourceRoot":"","sources":["../../../src/surface-block/canvas-renderer/renderer.ts"],"names":[],"mappings":"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","sourcesContent":["import { DisposableGroup, Slot } from '@blocksuite/global/utils';\n\nimport { requestConnectedFrame } from '../../_common/utils/event.js';\nimport { Viewport } from '../../root-block/edgeless/utils/viewport.js';\nimport type { IBound } from '../consts.js';\nimport type { SurfaceElementModel } from '../element-model/base.js';\nimport type { LayerManager } from '../managers/layer-manager.js';\nimport { RoughCanvas } from '../rough/canvas.js';\nimport { intersects } from '../utils/math-utils.js';\nimport { getBoundsWithRotation } from '../utils/math-utils.js';\nimport { modelRenderer } from './element-renderer/index.js';\n\n/**\n * An overlay is a layer covered on top of elements,\n * can be used for rendering non-CRDT state indicators.\n */\nexport abstract class Overlay {\n  protected _renderer!: Renderer;\n\n  constructor() {}\n\n  abstract render(ctx: CanvasRenderingContext2D, rc: RoughCanvas): void;\n\n  setRenderer(renderer: Renderer | null) {\n    // @ts-ignore\n    this._renderer = renderer;\n  }\n}\n\ntype EnvProvider = {\n  getVariableColor: (val: string) => string;\n  selectedElements?: () => string[];\n};\n\ntype RendererOptions = {\n  layerManager: LayerManager;\n  provider: EnvProvider;\n  enableStackingCanvas?: boolean;\n  onStackingCanvasCreated?: (canvas: HTMLCanvasElement) => void;\n};\n\nexport class Renderer extends Viewport {\n  get stackingCanvas() {\n    return this._stackingCanvas;\n  }\n\n  private _stackingCanvas: HTMLCanvasElement[] = [];\n\n  private _overlays = new Set<Overlay>();\n\n  private _shouldUpdate = false;\n\n  private _disposables = new DisposableGroup();\n\n  canvas: HTMLCanvasElement;\n\n  ctx: CanvasRenderingContext2D;\n\n  layerManager: LayerManager;\n\n  provider: Partial<EnvProvider>;\n\n  stackingCanvasUpdated = new Slot<HTMLCanvasElement[]>();\n\n  constructor(options: RendererOptions) {\n    super();\n\n    const canvas = document.createElement('canvas');\n\n    this.canvas = canvas;\n    this.ctx = this.canvas.getContext('2d') as CanvasRenderingContext2D;\n    this.layerManager = options.layerManager;\n    this.provider = options.provider ?? {};\n    this._initViewport();\n\n    options.enableStackingCanvas = options.enableStackingCanvas ?? false;\n    if (options.enableStackingCanvas) {\n      this._initStackingCanvas(options.onStackingCanvasCreated);\n    }\n  }\n\n  private _initViewport() {\n    let sizeUpdatedRafId: number | null = null;\n\n    this.viewportUpdated.on(() => {\n      this._shouldUpdate = true;\n    });\n\n    this.sizeUpdated.on(() => {\n      if (sizeUpdatedRafId) return;\n      sizeUpdatedRafId = requestConnectedFrame(() => {\n        sizeUpdatedRafId = null;\n        this._resetSize();\n        this._render();\n        this._shouldUpdate = false;\n      }, this._el);\n    });\n  }\n\n  private _initStackingCanvas(onCreated?: (canvas: HTMLCanvasElement) => void) {\n    const layer = this.layerManager;\n    const updateStackingCanvasSize = (canvases: HTMLCanvasElement[]) => {\n      this._stackingCanvas = canvases;\n\n      const sizeUpdater = this._canvasSizeUpdater();\n\n      canvases.filter(sizeUpdater.filter).forEach(sizeUpdater.update);\n    };\n    const updateStackingCanvas = () => {\n      /**\n       * we already have a main canvas, so the last layer should be skipped\n       */\n      const canvasLayers = layer.getCanvasLayers().slice(0, -1);\n      const canvases = [];\n      const currentCanvases = this._stackingCanvas;\n\n      for (let i = 0; i < canvasLayers.length; ++i) {\n        const layer = canvasLayers[i];\n        const created = i < currentCanvases.length;\n        const canvas = created\n          ? currentCanvases[i]\n          : document.createElement('canvas');\n\n        if (!created) {\n          this._stackingCanvas.push(canvas);\n          onCreated?.(canvas);\n        }\n\n        canvas.dataset.layerId = `[${layer.indexes[0]}--${layer.indexes[1]}]`;\n        canvas.style.zIndex = layer.zIndex.toString();\n        canvases.push(canvas);\n      }\n\n      this._stackingCanvas = canvases;\n      updateStackingCanvasSize(canvases);\n      this.stackingCanvasUpdated.emit(canvases);\n      this.refresh();\n    };\n\n    this._disposables.add(\n      this.layerManager.slots.layerUpdated.on(() => {\n        updateStackingCanvas();\n      })\n    );\n\n    updateStackingCanvas();\n  }\n\n  /**\n   * Specifying the actual size gives better results and more consistent behavior across browsers.\n   *\n   * Make sure the main canvas and the offscreen canvas or layer canvas are the same size.\n   *\n   * It is not recommended to set width and height to 100%.\n   */\n  private _canvasSizeUpdater(dpr = window.devicePixelRatio) {\n    const { _width, _height } = this;\n    const width = `${_width}px`;\n    const height = `${_height}px`;\n    const actualWidth = Math.ceil(_width * dpr);\n    const actualHeight = Math.ceil(_height * dpr);\n\n    return {\n      filter({ width, height }: HTMLCanvasElement) {\n        return width !== actualWidth || height !== actualHeight;\n      },\n      update(canvas: HTMLCanvasElement) {\n        canvas.style.width = width;\n        canvas.style.height = height;\n        canvas.width = actualWidth;\n        canvas.height = actualHeight;\n      },\n    };\n  }\n\n  private _resetSize() {\n    const sizeUpdater = this._canvasSizeUpdater();\n\n    sizeUpdater.update(this.canvas);\n\n    this._stackingCanvas.forEach(sizeUpdater.update);\n\n    this._shouldUpdate = true;\n  }\n\n  private _loop() {\n    requestConnectedFrame(() => {\n      if (this._shouldUpdate) {\n        this._shouldUpdate = false;\n        this._render();\n      }\n      this._loop();\n    }, this._el);\n  }\n\n  private _render() {\n    const { ctx, viewportBounds, zoom, cumulativeParentScale } = this;\n    const dpr = window.devicePixelRatio;\n    const scale = zoom * dpr;\n    const matrix = new DOMMatrix()\n      .scaleSelf(scale)\n      .scaleSelf(cumulativeParentScale);\n    /**\n     * if a layer does not have a corresponding canvas\n     * its element will be add to this array and drawing on the\n     * main canvas\n     */\n    let fallbackElement: SurfaceElementModel[] = [];\n\n    this.layerManager.getCanvasLayers().forEach((layer, idx) => {\n      if (!this._stackingCanvas[idx]) {\n        fallbackElement = fallbackElement.concat(layer.elements);\n        return;\n      }\n\n      const canvas = this._stackingCanvas[idx];\n      const ctx = canvas.getContext('2d') as CanvasRenderingContext2D;\n      const rc = new RoughCanvas(ctx.canvas);\n\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n      ctx.save();\n      ctx.setTransform(matrix);\n\n      this._renderByBound(ctx, matrix, rc, viewportBounds, layer.elements);\n    });\n\n    ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    ctx.save();\n\n    ctx.setTransform(matrix);\n\n    this._renderByBound(\n      ctx,\n      matrix,\n      new RoughCanvas(ctx.canvas),\n      viewportBounds,\n      fallbackElement,\n      true\n    );\n  }\n\n  private _renderByBound(\n    ctx: CanvasRenderingContext2D | null,\n    matrix: DOMMatrix,\n    rc: RoughCanvas,\n    bound: IBound,\n    surfaceElements?: SurfaceElementModel[],\n    overLay: boolean = false\n  ) {\n    if (!ctx) return;\n\n    const elements =\n      surfaceElements ?? this.layerManager.canvasGrid.search(bound);\n    for (const element of elements) {\n      ctx.save();\n\n      const display = element.display ?? true;\n      if (display && intersects(getBoundsWithRotation(element), bound)) {\n        const renderFn =\n          modelRenderer[element.type as keyof typeof modelRenderer];\n\n        if (!renderFn) {\n          console.warn(`Cannot find renderer for ${element.type}`);\n          ctx.restore();\n          continue;\n        }\n\n        ctx.globalAlpha = element.opacity ?? 1;\n        const dx = element.x - bound.x;\n        const dy = element.y - bound.y;\n\n        renderFn(element, ctx, matrix.translate(dx, dy), this, rc, bound);\n      }\n\n      ctx.restore();\n    }\n\n    if (overLay) {\n      for (const overlay of this._overlays) {\n        ctx.save();\n        ctx.translate(-bound.x, -bound.y);\n        overlay.render(ctx, rc);\n        ctx.restore();\n      }\n    }\n\n    ctx.restore();\n  }\n\n  getVariableColor(val: string) {\n    return this.provider.getVariableColor?.(val) ?? val;\n  }\n\n  refresh() {\n    this._shouldUpdate = true;\n  }\n\n  /**\n   * Used to attach main canvas, main canvas will always exist\n   * @param container\n   */\n  attach(container: HTMLElement) {\n    this.setContainer(container);\n    container.append(this.canvas);\n\n    this._resetSize();\n    this._loop();\n  }\n\n  getCanvasByBound(\n    bound: IBound = this.viewportBounds,\n    surfaceElements?: SurfaceElementModel[],\n    canvas?: HTMLCanvasElement,\n    clearBeforeDrawing?: boolean,\n    withZoom?: boolean\n  ): HTMLCanvasElement {\n    canvas = canvas || document.createElement('canvas');\n\n    const dpr = window.devicePixelRatio || 1;\n    if (canvas.width !== bound.w * dpr) canvas.width = bound.w * dpr;\n    if (canvas.height !== bound.h * dpr) canvas.height = bound.h * dpr;\n\n    canvas.style.width = `${bound.w}px`;\n    canvas.style.height = `${bound.h}px`;\n\n    const ctx = canvas.getContext('2d') as CanvasRenderingContext2D;\n    const matrix = new DOMMatrix().scaleSelf(withZoom ? dpr * this.zoom : dpr);\n    const rc = new RoughCanvas(canvas);\n\n    if (clearBeforeDrawing) ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.setTransform(matrix);\n\n    this._renderByBound(ctx, matrix, rc, bound, surfaceElements);\n\n    return canvas;\n  }\n\n  addOverlay(overlay: Overlay) {\n    overlay.setRenderer(this);\n    this._overlays.add(overlay);\n    this._shouldUpdate = true;\n  }\n\n  removeOverlay(overlay: Overlay) {\n    if (!this._overlays.has(overlay)) {\n      return;\n    }\n\n    overlay.setRenderer(null);\n    this._overlays.delete(overlay);\n    this._shouldUpdate = true;\n  }\n\n  override dispose(): void {\n    super.dispose();\n  }\n}\n"]}