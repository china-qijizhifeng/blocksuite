{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../../../src/surface-block/canvas-renderer/element-renderer/shape/index.ts"],"names":[],"mappings":"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","sourcesContent":["import type { IBound } from '../../../consts.js';\nimport type {\n  ShapeElementModel,\n  ShapeType,\n} from '../../../element-model/shape.js';\nimport type { RoughCanvas } from '../../../rough/canvas.js';\nimport { Bound } from '../../../utils/bound.js';\nimport type { Renderer } from '../../renderer.js';\nimport {\n  deltaInsertsToChunks,\n  getFontMetrics,\n  getFontString,\n  getLineWidth,\n  isRTL,\n  measureTextInDOM,\n  wrapTextDeltas,\n} from '../text/utils.js';\nimport { diamond } from './diamond.js';\nimport { ellipse } from './ellipse.js';\nimport { rect } from './rect.js';\nimport { triangle } from './triangle.js';\nimport { horizontalOffset, verticalOffset } from './utils.js';\n\nconst shapeRenderers: {\n  [key in ShapeType]: (\n    model: ShapeElementModel,\n    ctx: CanvasRenderingContext2D,\n    matrix: DOMMatrix,\n    renderer: Renderer,\n    rc: RoughCanvas\n  ) => void;\n} = {\n  diamond,\n  rect,\n  triangle,\n  ellipse,\n};\n\nexport function shape(\n  model: ShapeElementModel,\n  ctx: CanvasRenderingContext2D,\n  matrix: DOMMatrix,\n  renderer: Renderer,\n  rc: RoughCanvas\n) {\n  shapeRenderers[model.shapeType](model, ctx, matrix, renderer, rc);\n\n  if (model.textDisplay) {\n    renderText(model, ctx, renderer);\n  }\n}\n\nfunction renderText(\n  model: ShapeElementModel,\n  ctx: CanvasRenderingContext2D,\n  renderer: Renderer\n) {\n  const {\n    x,\n    y,\n    text,\n    color,\n    fontSize,\n    fontFamily,\n    fontWeight,\n    textAlign,\n    w,\n    h,\n    textVerticalAlign,\n    padding,\n  } = model;\n  if (!text) return;\n\n  const [verticalPadding, horPadding] = padding;\n  const font = getFontString(model);\n  const { lineGap, lineHeight } = measureTextInDOM(\n    fontFamily,\n    fontSize,\n    fontWeight\n  );\n  const metrics = getFontMetrics(fontFamily, fontSize, fontWeight);\n  const lines = deltaInsertsToChunks(\n    wrapTextDeltas(text, font, w - horPadding * 2)\n  );\n  const horOffset = horizontalOffset(model.w, model.textAlign, horPadding);\n  const vertOffset =\n    verticalOffset(\n      lines,\n      lineHeight + lineGap,\n      h,\n      textVerticalAlign,\n      verticalPadding\n    ) +\n    metrics.fontBoundingBoxAscent +\n    lineGap / 2;\n  let maxLineWidth = 0;\n\n  ctx.font = font;\n  ctx.fillStyle = renderer.getVariableColor(color);\n  ctx.textAlign = textAlign;\n  ctx.textBaseline = 'alphabetic';\n\n  for (const [lineIndex, line] of lines.entries()) {\n    for (const delta of line) {\n      const str = delta.insert;\n      const rtl = isRTL(str);\n      const shouldTemporarilyAttach = rtl && !ctx.canvas.isConnected;\n      if (shouldTemporarilyAttach) {\n        // to correctly render RTL text mixed with LTR, we have to append it\n        // to the DOM\n        document.body.append(ctx.canvas);\n      }\n\n      if (ctx.canvas.dir !== (rtl ? 'rtl' : 'ltr')) {\n        ctx.canvas.setAttribute('dir', rtl ? 'rtl' : 'ltr');\n      }\n\n      ctx.fillText(\n        str,\n        // 0.5 is the dom editor padding to make the text align with the DOM text\n        horOffset + 0.5,\n        lineIndex * lineHeight + vertOffset\n      );\n\n      maxLineWidth = Math.max(maxLineWidth, getLineWidth(str, font));\n\n      if (shouldTemporarilyAttach) {\n        ctx.canvas.remove();\n      }\n    }\n  }\n\n  const bound = new Bound(\n    x + (w - maxLineWidth) / 2,\n    y + vertOffset - 2,\n    maxLineWidth,\n    lineHeight * lines.length\n  ) as IBound;\n\n  bound.rotate = model.rotate ?? 0;\n  model.textBound = bound;\n}\n"]}