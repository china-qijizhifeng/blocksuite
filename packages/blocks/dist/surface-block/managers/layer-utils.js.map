{"version":3,"file":"layer-utils.js","sourceRoot":"","sources":["../../../src/surface-block/managers/layer-utils.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Doc } from '@blocksuite/store';\n\nimport { SurfaceGroupLikeModel } from '../element-model/base.js';\nimport type { SurfaceBlockModel } from '../surface-model.js';\nimport type { Layer } from './layer-manager.js';\n\nexport function getLayerEndZIndex(layers: Layer[], layerIndex: number) {\n  const layer = layers[layerIndex];\n  return layer\n    ? layer.type === 'block'\n      ? layer.zIndex + layer.elements.length - 1\n      : layer.zIndex\n    : 1;\n}\n\nexport function updateLayersZIndex(layers: Layer[], startIdx: number) {\n  const startLayer = layers[startIdx];\n  let curIndex = startLayer.zIndex;\n\n  for (let i = startIdx; i < layers.length; ++i) {\n    const curLayer = layers[i];\n\n    curLayer.zIndex = curIndex;\n    curIndex += curLayer.type === 'block' ? curLayer.elements.length : 1;\n  }\n}\n\nexport function getElementIndex(indexable: BlockSuite.EdgelessModelType) {\n  const groups = indexable.groups;\n\n  if (groups.length > 1) {\n    return (\n      groups\n        .map(group => group.index)\n        .reverse()\n        .slice(1)\n        .join('-') + `-${indexable.index}`\n    );\n  }\n\n  return indexable.index;\n}\n\nexport function ungroupIndex(index: string) {\n  return index.split('-')[0];\n}\n\nexport function insertToOrderedArray(\n  array: BlockSuite.EdgelessModelType[],\n  element: BlockSuite.EdgelessModelType\n) {\n  let idx = 0;\n  while (idx < array.length && compare(array[idx], element) < 0) {\n    ++idx;\n  }\n\n  array.splice(idx, 0, element);\n}\n\nexport function removeFromOrderedArray(\n  array: BlockSuite.EdgelessModelType[],\n  element: BlockSuite.EdgelessModelType\n) {\n  const idx = array.indexOf(element);\n\n  if (idx !== -1) {\n    array.splice(idx, 1);\n  }\n}\n\nexport function isInRange(\n  edges: [BlockSuite.EdgelessModelType, BlockSuite.EdgelessModelType],\n  target: BlockSuite.EdgelessModelType\n) {\n  return compare(target, edges[0]) >= 0 && compare(target, edges[1]) < 0;\n}\n\nexport function renderableInEdgeless(\n  doc: Doc,\n  surface: SurfaceBlockModel,\n  block: BlockSuite.EdgelessBlockModelType\n) {\n  const parent = doc.getParent(block);\n\n  return parent === doc.root || parent === surface;\n}\n\nexport function compare(\n  a: BlockSuite.EdgelessModelType,\n  b: BlockSuite.EdgelessModelType\n) {\n  if (a instanceof SurfaceGroupLikeModel && a.hasDescendant(b)) {\n    return -1;\n  } else if (b instanceof SurfaceGroupLikeModel && b.hasDescendant(a)) {\n    return 1;\n  } else {\n    const aGroups = a.groups;\n    const bGroups = b.groups;\n    const minGroups = Math.min(aGroups.length, bGroups.length);\n\n    for (let i = 0; i < minGroups; ++i) {\n      if (aGroups[i] !== bGroups[i]) {\n        const aGroup = aGroups[i] ?? a;\n        const bGroup = bGroups[i] ?? b;\n\n        return aGroup.index === bGroup.index\n          ? 0\n          : aGroup.index < bGroup.index\n            ? -1\n            : 1;\n      }\n    }\n\n    if (a.index < b.index) return -1;\n    else if (a.index > b.index) return 1;\n    return 0;\n  }\n}\n"]}