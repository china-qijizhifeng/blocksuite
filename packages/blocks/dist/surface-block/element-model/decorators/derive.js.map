{"version":3,"file":"derive.js","sourceRoot":"","sources":["../../../../src/surface-block/element-model/decorators/derive.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,IAAI,EAAE,MAAM,oCAAoC,CAAC;AAE1D,OAAO,EACL,iBAAiB,EACjB,iBAAiB,EACjB,iBAAiB,GAClB,MAAM,aAAa,CAAC;AAErB,MAAM,YAAY,GAAG,MAAM,CAAC,QAAQ,CAAC,CAAC;AAEtC,SAAS,cAAc,CACrB,KAAc,EACd,IAAqB;IAIrB,OAAO,iBAAiB,CAAC,KAAK,EAAE,YAAY,EAAE,IAAI,CAAC,CAAC;AACtD,CAAC;AAED,MAAM,UAAU,mBAAmB,CACjC,IAAqB,EACrB,SAAkB,EAClB,QAA6B;IAE7B,MAAM,SAAS,GAAG,MAAM,CAAC,cAAc,CAAC,QAAQ,CAAC,CAAC;IAClD,MAAM,cAAc,GAAG,iBAAiB,EAAE,CAAC;IAE3C,IAAI,cAAc,CAAC,QAAQ,IAAI,cAAc,CAAC,QAAQ,EAAE,CAAC;QACvD,OAAO,IAAI,CAAC;IACd,CAAC;IAED,MAAM,SAAS,GAAG,cAAc,CAAC,SAAS,EAAE,IAAc,CAAE,CAAC;IAE7D,OAAO,SAAS;QACd,CAAC,CAAC,SAAS,CAAC,MAAM,CACd,CAAC,YAAY,EAAE,EAAE,EAAE,EAAE;YACnB,MAAM,KAAK,GAAG,EAAE,CAAC,SAAS,EAAE,QAAQ,CAAC,CAAC;YAEtC,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,GAAG,EAAE,KAAK,CAAC,EAAE,EAAE;gBAC7C,YAAY,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC;YAC5B,CAAC,CAAC,CAAC;YAEH,OAAO,YAAY,CAAC;QACtB,CAAC,EACD,EAA6B,CAC9B;QACH,CAAC,CAAC,IAAI,CAAC;AACX,CAAC;AAED,MAAM,UAAU,iBAAiB,CAC/B,YAA4C,EAC5C,QAA6B;IAE7B,IAAI,YAAY,EAAE,CAAC;QACjB,MAAM,cAAc,GAAG,iBAAiB,EAAE,CAAC;QAC3C,cAAc,CAAC,QAAQ,GAAG,IAAI,CAAC;QAC/B,IAAI,CAAC,YAAY,CAAC,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE;YAC/B,aAAa;YACb,QAAQ,CAAC,GAAG,CAAC,GAAG,YAAY,CAAC,GAAG,CAAC,CAAC;QACpC,CAAC,CAAC,CAAC;QACH,cAAc,CAAC,QAAQ,GAAG,KAAK,CAAC;IAClC,CAAC;AACH,CAAC;AAED;;;;;;;;;;;;;GAaG;AACH,MAAM,UAAU,MAAM,CACpB,EAI4B;IAE5B,OAAO,SAAS,eAAe,CAC7B,CAAU,EACV,OAAsC;QAEtC,MAAM,IAAI,GAAG,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;QAClC,OAAO;YACL,IAAI,CAA4B,CAAI;gBAClC,MAAM,KAAK,GAAG,MAAM,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;gBAC1C,MAAM,OAAO,GAAG,cAAc,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;gBAE5C,IAAI,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE,CAAC;oBAC3B,OAAO,CAAC,IAAI,CAAC,EAAyB,CAAC,CAAC;gBAC1C,CAAC;qBAAM,CAAC;oBACN,iBAAiB,CAAC,YAAY,EAAE,KAAK,EAAE,IAAc,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;gBAC/D,CAAC;gBAED,OAAO,CAAC,CAAC;YACX,CAAC;SACsD,CAAC;IAC5D,CAAC,CAAC;AACJ,CAAC","sourcesContent":["import { keys } from '../../../_common/utils/iterable.js';\nimport type { SurfaceElementModel } from '../base.js';\nimport {\n  getDecoratorState,\n  getObjectPropMeta,\n  setObjectPropMeta,\n} from './common.js';\n\nconst deriveSymbol = Symbol('derive');\n\nfunction getDerivedMeta(\n  proto: unknown,\n  prop: string | symbol\n):\n  | null\n  | ((propValue: unknown, instance: unknown) => Record<string, unknown>)[] {\n  return getObjectPropMeta(proto, deriveSymbol, prop);\n}\n\nexport function getDeriveProperties(\n  prop: string | symbol,\n  propValue: unknown,\n  receiver: SurfaceElementModel\n) {\n  const prototype = Object.getPrototypeOf(receiver);\n  const decoratorState = getDecoratorState();\n\n  if (decoratorState.deriving || decoratorState.creating) {\n    return null;\n  }\n\n  const deriveFns = getDerivedMeta(prototype, prop as string)!;\n\n  return deriveFns\n    ? deriveFns.reduce(\n        (derivedProps, fn) => {\n          const props = fn(propValue, receiver);\n\n          Object.entries(props).forEach(([key, value]) => {\n            derivedProps[key] = value;\n          });\n\n          return derivedProps;\n        },\n        {} as Record<string, unknown>\n      )\n    : null;\n}\n\nexport function updateDerivedProp(\n  derivedProps: Record<string, unknown> | null,\n  receiver: SurfaceElementModel\n) {\n  if (derivedProps) {\n    const decoratorState = getDecoratorState();\n    decoratorState.deriving = true;\n    keys(derivedProps).forEach(key => {\n      // @ts-ignore\n      receiver[key] = derivedProps[key];\n    });\n    decoratorState.deriving = false;\n  }\n}\n\n/**\n * The derive decorator is used to derive other properties' update when the\n * decorated property is updated through assignment in the local.\n *\n * Note:\n * 1. The first argument of the function is the new value of the decorated property\n *    before the `convert` decorator is called.\n * 2. The decorator function will execute after the decorated property has been updated.\n * 3. The decorator function will not execute during model creation.\n * 4. The decorator function will not execute if the decorated property is updated through\n *    the Y map. That is to say, if other peers update the property will not trigger this decorator\n * @param fn\n * @returns\n */\nexport function derive<V, T extends SurfaceElementModel>(\n  fn: (\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    propValue: any,\n    instance: T\n  ) => Record<string, unknown>\n) {\n  return function deriveDecorator(\n    _: unknown,\n    context: ClassAccessorDecoratorContext\n  ) {\n    const prop = String(context.name);\n    return {\n      init(this: SurfaceElementModel, v: V) {\n        const proto = Object.getPrototypeOf(this);\n        const derived = getDerivedMeta(proto, prop);\n\n        if (Array.isArray(derived)) {\n          derived.push(fn as (typeof derived)[0]);\n        } else {\n          setObjectPropMeta(deriveSymbol, proto, prop as string, [fn]);\n        }\n\n        return v;\n      },\n    } as ClassAccessorDecoratorResult<SurfaceElementModel, V>;\n  };\n}\n"]}