{"version":3,"file":"delta.js","sourceRoot":"","sources":["../../src/services/delta.ts"],"names":[],"mappings":"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","sourcesContent":["import { html, render } from 'lit';\nimport { repeat } from 'lit/directives/repeat.js';\n\nimport type { VLine } from '../index.js';\nimport type { InlineEditor } from '../inline-editor.js';\nimport type { DeltaInsert } from '../types.js';\nimport type { DeltaEntry, InlineRange } from '../types.js';\nimport type { BaseTextAttributes } from '../utils/index.js';\nimport {\n  deltaInsertsToChunks,\n  renderElement,\n  transformDeltasToEmbedDeltas,\n} from '../utils/index.js';\n\nexport class DeltaService<TextAttributes extends BaseTextAttributes> {\n  constructor(readonly editor: InlineEditor<TextAttributes>) {}\n\n  get deltas() {\n    return this.editor.yText.toDelta() as DeltaInsert<TextAttributes>[];\n  }\n\n  mapDeltasInInlineRange = <Result>(\n    inlineRange: InlineRange,\n    callback: (\n      delta: DeltaInsert<TextAttributes>,\n      rangeIndex: number,\n      deltaIndex: number\n    ) => Result,\n    normalize = false\n  ) => {\n    const deltas = normalize\n      ? transformDeltasToEmbedDeltas(this.editor, this.deltas)\n      : this.deltas;\n    const result: Result[] = [];\n\n    deltas.reduce((rangeIndex, delta, deltaIndex) => {\n      const length = delta.insert.length;\n      const from = inlineRange.index - length;\n      const to = inlineRange.index + inlineRange.length;\n\n      const deltaInRange =\n        rangeIndex >= from &&\n        (rangeIndex < to ||\n          (inlineRange.length === 0 && rangeIndex === inlineRange.index));\n\n      if (deltaInRange) {\n        const value = callback(delta, rangeIndex, deltaIndex);\n        result.push(value);\n      }\n\n      return rangeIndex + length;\n    }, 0);\n\n    return result;\n  };\n\n  isNormalizedDeltaSelected(\n    normalizedDeltaIndex: number,\n    inlineRange: InlineRange\n  ): boolean {\n    let result = false;\n    if (inlineRange.length >= 1) {\n      this.editor.mapDeltasInInlineRange(\n        inlineRange,\n        (_, rangeIndex, deltaIndex) => {\n          if (\n            deltaIndex === normalizedDeltaIndex &&\n            rangeIndex >= inlineRange.index\n          ) {\n            result = true;\n          }\n        },\n        // we need to normalize the delta here,\n        true\n      );\n    }\n\n    return result;\n  }\n\n  /**\n   * Here are examples of how this function computes and gets the delta.\n   *\n   * We have such a text:\n   * ```\n   * [\n   *   {\n   *      insert: 'aaa',\n   *      attributes: { bold: true },\n   *   },\n   *   {\n   *      insert: 'bbb',\n   *      attributes: { italic: true },\n   *   },\n   * ]\n   * ```\n   *\n   * `getDeltaByRangeIndex(0)` returns `{ insert: 'aaa', attributes: { bold: true } }`.\n   *\n   * `getDeltaByRangeIndex(1)` returns `{ insert: 'aaa', attributes: { bold: true } }`.\n   *\n   * `getDeltaByRangeIndex(3)` returns `{ insert: 'aaa', attributes: { bold: true } }`.\n   *\n   * `getDeltaByRangeIndex(4)` returns `{ insert: 'bbb', attributes: { italic: true } }`.\n   */\n  getDeltaByRangeIndex = (rangeIndex: number) => {\n    const deltas = this.deltas;\n\n    let index = 0;\n    for (const delta of deltas) {\n      if (index + delta.insert.length >= rangeIndex) {\n        return delta;\n      }\n      index += delta.insert.length;\n    }\n\n    return null;\n  };\n\n  /**\n   * Here are examples of how this function computes and gets the deltas.\n   *\n   * We have such a text:\n   * ```\n   * [\n   *   {\n   *      insert: 'aaa',\n   *      attributes: { bold: true },\n   *   },\n   *   {\n   *      insert: 'bbb',\n   *      attributes: { italic: true },\n   *   },\n   *   {\n   *      insert: 'ccc',\n   *      attributes: { underline: true },\n   *   },\n   * ]\n   * ```\n   *\n   * `getDeltasByInlineRange({ index: 0, length: 0 })` returns\n   * ```\n   * [{ insert: 'aaa', attributes: { bold: true }, }, { index: 0, length: 3, }]]\n   * ```\n   *\n   * `getDeltasByInlineRange({ index: 0, length: 1 })` returns\n   * ```\n   * [{ insert: 'aaa', attributes: { bold: true }, }, { index: 0, length: 3, }]]\n   * ```\n   *\n   * `getDeltasByInlineRange({ index: 0, length: 4 })` returns\n   * ```\n   * [{ insert: 'aaa', attributes: { bold: true }, }, { index: 0, length: 3, }],\n   *  [{ insert: 'bbb', attributes: { italic: true }, }, { index: 3, length: 3, }]]\n   * ```\n   *\n   * `getDeltasByInlineRange({ index: 3, length: 1 })` returns\n   * ```\n   * [{ insert: 'aaa', attributes: { bold: true }, }, { index: 0, length: 3, }],\n   *  [{ insert: 'bbb', attributes: { italic: true }, }, { index: 3, length: 3, }]]\n   * ```\n   *\n   * `getDeltasByInlineRange({ index: 3, length: 3 })` returns\n   * ```\n   * [{ insert: 'aaa', attributes: { bold: true }, }, { index: 0, length: 3, }],\n   *  [{ insert: 'bbb', attributes: { italic: true }, }, { index: 3, length: 3, }]]\n   * ```\n   *\n   *  `getDeltasByInlineRange({ index: 3, length: 4 })` returns\n   * ```\n   * [{ insert: 'aaa', attributes: { bold: true }, }, { index: 0, length: 3, }],\n   *  [{ insert: 'bbb', attributes: { italic: true }, }, { index: 3, length: 3, }],\n   *  [{ insert: 'ccc', attributes: { underline: true }, }, { index: 6, length: 3, }]]\n   * ```\n   */\n  getDeltasByInlineRange = (\n    inlineRange: InlineRange\n  ): DeltaEntry<TextAttributes>[] => {\n    return this.mapDeltasInInlineRange(\n      inlineRange,\n      (delta, index): DeltaEntry<TextAttributes> => [\n        delta,\n        { index, length: delta.insert.length },\n      ]\n    );\n  };\n\n  // render current deltas to VLines\n  render = async (syncInlineRange = true) => {\n    if (!this.editor.mounted) return;\n\n    this.editor.slots.render.emit();\n\n    const rootElement = this.editor.rootElement;\n\n    const normalizedDeltas = transformDeltasToEmbedDeltas(\n      this.editor,\n      this.deltas\n    );\n    const chunks = deltaInsertsToChunks(normalizedDeltas);\n\n    let normalizedDeltaIndex = 0;\n    // every chunk is a line\n    const lines = chunks.map(chunk => {\n      if (chunk.length > 0) {\n        const lineDeltas: [DeltaInsert<TextAttributes>, number][] = [];\n        chunk.forEach(delta => {\n          lineDeltas.push([delta, normalizedDeltaIndex]);\n          normalizedDeltaIndex++;\n        });\n\n        const elements: VLine['elements'] = lineDeltas.map(\n          ([delta, normalizedDeltaIndex]) => {\n            let selected = false;\n            const inlineRange = this.editor.getInlineRange();\n            if (inlineRange) {\n              selected = this.isNormalizedDeltaSelected(\n                normalizedDeltaIndex,\n                inlineRange\n              );\n            }\n\n            return [\n              renderElement(\n                delta,\n                this.editor.attributeService.normalizeAttributes,\n                selected\n              ),\n              delta,\n            ];\n          }\n        );\n\n        return html`<v-line .elements=${elements}></v-line>`;\n      } else {\n        return html`<v-line .elements=${[]}></v-line>`;\n      }\n    });\n\n    try {\n      render(\n        repeat(\n          lines.map((line, i) => ({ line, index: i })),\n          entry => entry.index,\n          entry => entry.line\n        ),\n        rootElement\n      );\n    } catch (_) {\n      // Lit may be crashed by IME input and we need to rerender whole editor for it\n      this.editor.rerenderWholeEditor();\n      await this.editor.waitForUpdate();\n    }\n\n    await this.editor.waitForUpdate();\n\n    if (syncInlineRange) {\n      // We need to synchronize the selection immediately after rendering is completed,\n      // otherwise there is a possibility of an error in the cursor position\n      this.editor.rangeService.syncInlineRange();\n    }\n\n    this.editor.slots.renderComplete.emit();\n  };\n}\n"]}