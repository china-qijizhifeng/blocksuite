{"version":3,"file":"mindmap.js","sourceRoot":"","sources":["../../../src/ai/messages/mindmap.ts"],"names":[],"mappings":"AAKA,OAAO,EAAE,iBAAiB,EAAE,kBAAkB,EAAE,MAAM,oBAAoB,CAAC;AAC3E,OAAO,EAAE,IAAI,EAAE,MAAM,0BAA0B,CAAC;AAChD,OAAO,EAAE,IAAI,EAAE,OAAO,EAAE,MAAM,KAAK,CAAC;AAEpC,OAAO,EAAE,UAAU,EAAE,MAAM,gBAAgB,CAAC;AAE5C,IAAI,CAAC,kBAAkB,CAAC,CAAC;AAEzB,MAAM,CAAC,MAAM,qBAAqB,GAUiB,CAAC,IAAI,EAAE,GAAG,EAAE,KAAK,EAAE,EAAE;IACtE,OAAO,CAAC,MAAM,EAAE,KAAK,EAAE,EAAE;QACvB,IAAI,KAAK,KAAK,YAAY,EAAE,CAAC;YAC3B,MAAM,KAAK,GAAG,UAAU,CAAC,IAAI,CAAC,CAAC;YAC/B,KAAK,CAAC,iBAAiB,EAAE,qBAAqB,CAAC,CAAC,CAAC,CAAC;QACpD,CAAC;QAED,IAAI,KAAK,KAAK,UAAU,IAAI,KAAK,KAAK,OAAO,EAAE,CAAC;YAC9C,OAAO,OAAO,CAAC;QACjB,CAAC;QAED,OAAO,IAAI,CAAA;aACF,GAAG;cACF,IAAI;gBACF,MAAM;sBACA,KAAK;sBACL,KAAK,KAAK,SAAS;gBACzB,GAAG;6BACU,CAAC;IAC5B,CAAC,CAAC;AACJ,CAAC,CAAC;AAEF;;;GAGG;AACH,MAAM,CAAC,MAAM,4BAA4B,GAaU,CAAC,IAAI,EAAE,GAAG,EAAE,OAAO,EAAE,EAAE;IACxE,OAAO,CAAC,MAAM,EAAE,KAAK,EAAE,EAAE;QACvB,IAAI,KAAK,KAAK,UAAU,EAAE,CAAC;YACzB,MAAM,KAAK,GAAG,UAAU,CAAC,IAAI,CAAC,CAAC;YAC/B,KAAK,CAAC,iBAAiB,EAAE,qBAAqB,CAAC,CAAC,CAAC,CAAC;YAClD,OAAO,OAAO,CAAC;QACjB,CAAC;QAED,GAAG,CAAC,GAAG,CAAC;YACN,IAAI,EAAE,iBAAiB,CAAC,MAAM,EAAE,IAAI,CAAC,GAAG,CAAC;SAC1C,CAAC,CAAC;QAEH,OAAO,CAAC,GAAG,CAAC,CAAC;QAEb,OAAO,OAAO,CAAC;IACjB,CAAC,CAAC;AACJ,CAAC,CAAC","sourcesContent":["import type { EditorHost } from '@blocksuite/block-std';\nimport type {\n  AffineAIPanelWidgetConfig,\n  MindmapStyle,\n} from '@blocksuite/blocks';\nimport { markdownToMindmap, MiniMindmapPreview } from '@blocksuite/blocks';\nimport { noop } from '@blocksuite/global/utils';\nimport { html, nothing } from 'lit';\n\nimport { getAIPanel } from '../ai-panel.js';\n\nnoop(MiniMindmapPreview);\n\nexport const createMindmapRenderer: (\n  host: EditorHost,\n  /**\n   * Used to store data for later use during rendering.\n   */\n  ctx: {\n    get: () => Record<string, unknown>;\n    set: (data: Record<string, unknown>) => void;\n  },\n  style?: MindmapStyle\n) => AffineAIPanelWidgetConfig['answerRenderer'] = (host, ctx, style) => {\n  return (answer, state) => {\n    if (state === 'generating') {\n      const panel = getAIPanel(host);\n      panel.generatingElement?.updateLoadingProgress(2);\n    }\n\n    if (state !== 'finished' && state !== 'error') {\n      return nothing;\n    }\n\n    return html`<mini-mindmap-preview\n      .ctx=${ctx}\n      .host=${host}\n      .answer=${answer}\n      .mindmapStyle=${style}\n      .templateShow=${style === undefined}\n      .height=${300}\n    ></mini-mindmap-preview>`;\n  };\n};\n\n/**\n * Creates a renderer for executing a handler.\n * The ai panel will not display anything after the answer is generated.\n */\nexport const createMindmapExecuteRenderer: (\n  host: EditorHost,\n  /**\n   * Used to store data for later use during rendering.\n   */\n  ctx: {\n    get: () => Record<string, unknown>;\n    set: (data: Record<string, unknown>) => void;\n  },\n  handler: (ctx: {\n    get: () => Record<string, unknown>;\n    set: (data: Record<string, unknown>) => void;\n  }) => void\n) => AffineAIPanelWidgetConfig['answerRenderer'] = (host, ctx, handler) => {\n  return (answer, state) => {\n    if (state !== 'finished') {\n      const panel = getAIPanel(host);\n      panel.generatingElement?.updateLoadingProgress(2);\n      return nothing;\n    }\n\n    ctx.set({\n      node: markdownToMindmap(answer, host.doc),\n    });\n\n    handler(ctx);\n\n    return nothing;\n  };\n};\n"]}