export declare const demoScript = "\n    <html>\n    <header>\n    <script type='importmap'>\n  {\n    \"imports\": {\n      \"three\": \"https://unpkg.com/three@0.158.0/build/three.module.js\",\n      \"three/addons/\": \"https://unpkg.com/three@0.158.0/examples/jsm/\"\n    }\n  }\n</script>\n</header>\n    <body>\n    <script  type='module'>import * as THREE from \"three\";\nimport {OrbitControls} from \"three/addons/controls/OrbitControls.js\";\n\n\nlet scene = new THREE.Scene();\nlet camera = new THREE.PerspectiveCamera(30, innerWidth / innerHeight, 1, 1000);\ncamera.position.set(0, 10, 10).setLength(17);\nlet renderer = new THREE.WebGLRenderer({antialias: true});\nrenderer.setSize(innerWidth, innerHeight);\ndocument.body.appendChild(renderer.domElement);\n\nwindow.addEventListener(\"resize\", event => {\n  camera.aspect = innerWidth / innerHeight;\n  camera.updateProjectionMatrix();\n  renderer.setSize(innerWidth, innerHeight);\n})\n\nlet controls = new OrbitControls(camera, renderer.domElement);\ncontrols.enableDamping = true;\n\nlet gu = {\n  time: {value: 0}\n}\n\nlet params = {\n  instanceCount: {value: 10},\n  instanceLength: {value: 1.75},\n  instanceGap: {value: 0.5},\n  profileFactor: {value: 1.5}\n}\n\nlet ig = new THREE.InstancedBufferGeometry().copy(new THREE.BoxGeometry(1, 1, 1, 100, 1, 1).translate(0.5, 0, 0));\nig.instanceCount = params.instanceCount.value;\n\nlet m = new THREE.MeshBasicMaterial({\n  vertexColors: true,\n  onBeforeCompile: shader => {\n    shader.uniforms.time = gu.time;\n    shader.uniforms.instanceCount = params.instanceCount;\n    shader.uniforms.instanceLength = params.instanceLength;\n    shader.uniforms.instanceGap = params.instanceGap;\n    shader.uniforms.profileFactor = params.profileFactor;\n    shader.vertexShader = `\n      uniform float time;\n      \n      uniform float instanceCount;\n      uniform float instanceLength;\n      uniform float instanceGap;\n      \n      uniform float profileFactor;\n      \n      varying float noGrid;\n      \n      mat2 rot(float a){return mat2(cos(a), sin(a), -sin(a), cos(a));}\n      \n      ${shader.vertexShader}\n    `.replace(\n      `#include <begin_vertex>`,\n      `#include <begin_vertex>\n      \n        float t = time * 0.1;\n        \n        float iID = float(gl_InstanceID);\n        \n        float instanceTotalLength = instanceLength + instanceGap;\n        float instanceFactor = instanceLength / instanceTotalLength;\n        \n        float circleLength = instanceTotalLength * instanceCount;\n        float circleRadius = circleLength / PI2;\n        \n        float partAngle = PI2 / instanceCount;\n        float boxAngle = partAngle * instanceFactor;\n\n        float partTurn = PI / instanceCount;\n        float boxTurn = partTurn * instanceFactor;\n        \n        float startAngle = t + partAngle * iID;\n        float startTurn = t * 0.5 + partTurn * iID;\n        \n        float angleFactor = position.x;\n        \n        float angle = startAngle + boxAngle * angleFactor;\n        float turn = startTurn + boxTurn * angleFactor;\n        \n        vec3 pos = vec3(0, position.y, position.z);\n        pos.yz *= rot(turn);\n        pos.yz *= profileFactor;\n        pos.z += circleRadius;\n        pos.xz *= rot(angle);\n        \n        transformed = pos;\n        float nZ = floor(abs(normal.z) + 0.1);\n        float nX = floor(abs(normal.x) + 0.1);\n        noGrid = 1. - nX;\n        vColor = vec3(nZ == 1. ? 0.1 : nX == 1. ? 0. : 0.01);\n      `\n    );\n    //console.log(shader.vertexShader);\n    shader.fragmentShader = `\n      varying float noGrid;\n      \n      float lines(vec2 coord, float thickness){\n        vec2 grid = abs(fract(coord - 0.5) - 0.5) / fwidth(coord) / thickness;\n        float line = min(grid.x, grid.y);\n        return 1.0 - min(line, 1.0);\n      }\n      ${shader.fragmentShader}\n    `.replace(\n      `#include <color_fragment>`,\n      `#include <color_fragment>\n        \n        float multiply = vColor.r > 0.05 ? 3. : 2.;\n        float edges = lines(vUv, 3.);\n        float grid = min(noGrid, lines(vUv * multiply, 1.));\n        diffuseColor.rgb = mix(diffuseColor.rgb, vec3(1), max(edges, grid));\n      `\n    )\n    //console.log(shader.fragmentShader)\n  }\n});\nm.defines = {\"USE_UV\": \"\"};\n\nlet o = new THREE.Mesh(ig, m);\nscene.add(o)\no.rotation.z = -Math.PI * 0.25;\n\nlet clock = new THREE.Clock();\nlet t = 0;\n\nrenderer.setAnimationLoop(()=>{\n  let dt = clock.getDelta();\n  t += dt;\n  gu.time.value = t;\n  controls.update();\n  renderer.render(scene, camera);\n})\n</script>\n</body>\n</html>";
//# sourceMappingURL=demo-script.d.ts.map